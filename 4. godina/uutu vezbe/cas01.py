# -*- coding: utf-8 -*-
"""cas01.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J_o_LlBK_maP4A4MSGNI-baNyaLcSlek
"""

import math
import statistics
from itertools import combinations

"""**1. Koliko ima prostih slučajnih uzoraka bez ponavljanja, a koliko sa ponavljanjem, ako se vadi uzorak obima 7 iz populacije koja sadrži 20 jediniki?**"""

n = 7
N = 20

# bez ponavljanja
f = math.factorial
f(N) / f(n) / f(N-n) # N nad n

# sa ponavljanjem
N**n

"""**2. Marko ima 7 jabuka, Petar 2, Jovan 2 i Saša 6. Da li je ocena ukupnog broja jabuka nepristrasna, ako se uzorak obima 2 bira tako da je verovatnoća da su Marko i Petar u uzorku 1/3, verovatnoća da su Marko i Jovan u uzorku 1/2, verovatnoća da su Petar i Jovan 1/6, dok je verovatnoća izbora svih ostalih uzoraka jednaka 0. (Kao ocena ukupnog broja jabuka koristi se statistika t = NY).**"""

populacija = [1, 2, 3, 4] # Marko, Petar, Jovan, Sasa
Y = [7, 2, 2, 6]

N = len(populacija)

uzorci = [[1, 2], [1, 3], [2, 3]]
P_uzorka = [1/3, 1/2, 1/6]

Y_sr = []
for i in range(0, len(uzorci)):
    Y_sr.append(statistics.mean([Y[uzorci[i][0]-1], Y[uzorci[i][1]-1]]))

print(Y_sr)

t_ocena = []
for i in range(len(Y_sr)):
    t_ocena.append(N*Y_sr[i])

print(t_ocena)

E_t_ocena = sum([x*y for x, y in zip(t_ocena, P_uzorka)])
print(E_t_ocena)

t = sum(Y)
print(t)

t == E_t_ocena # False -> ocena nije nepristrasna

"""**3. Ispitati da li je bolja (u srednjekvadratnom smislu) ocena ukupne sume obeležja (t=NY) na osnovu uzorka obima 2, ili na osnovu uzorka obima 3, iz populacije {1,2,3,4} ako se koristi prost slučajan uzorak bez ponavljanja. Obeležje populacije je redni broj jedinke.**"""

n1 = 2
n2 = 3

populacija = [1, 2, 3, 4]
Y = [1, 2, 3, 4]

N = len(populacija)

def helperFunction(n):
    M = combinations(populacija, n)
    M = list(M)

    f = math.factorial
    broj_kombinacija = f(N) / f(n) / f(N-n)

    P_uzorka = [1/broj_kombinacija for _ in range(int(broj_kombinacija))]

    return M, P_uzorka

psu_1, P_uzorka_1 = helperFunction(n1)
psu_2, P_uzorka_2 = helperFunction(n2)

Y_sr_1 = []
for i in range(len(psu_1)):
    Y_sr_1.append(statistics.mean([Y[psu_1[i][0]-1], Y[psu_1[i][1]-1]]))

print(Y_sr_1)

Y_sr_2 = []
for i in range(len(psu_2)):
    Y_sr_2.append(statistics.mean([Y[psu_2[i][0]-1], Y[psu_2[i][1]-1], Y[psu_2[i][2]-1]]))

print(Y_sr_2)

t = sum(Y)
print(t)

MSE_1 = sum([ (N*x-t)**2 * y for x,y in zip(Y_sr_1, P_uzorka_1) ])
MSE_2 = sum([ (N*x-t)**2 * y for x,y in zip(Y_sr_2, P_uzorka_2) ])

print(MSE_1)
print(MSE_2)
# MSE2 < MSE1 -> bolja je ocena za n = 3

"""**4. Iz skupa {1,2,3,4,5,6,7,8} vade se uzorci bez ponavljanja obima 2, tako da svaki koji sadrži neparan broj ima verovatnoću 0. Oni uzorci koji sadrže 2 imaju verovatnoću obrnuto proporcionalnu  drugom elementu uzorka, a oni koji sadrže 4, a ne sadrže 2, imaju verovatnoću 1/8. Ispitati nepristrasnost ocene srednje vrednosti i odrediti njenu srednjekvadratnu grešku.**"""

populacija = [1, 2, 3, 4, 5, 6, 7, 8]
Y = populacija

N = len(populacija)
n = 2

uzorci = combinations(populacija, n)
uzorci = list(uzorci)

f = math.factorial
broj_kombinacija = int(f(N) / f(n) / f(N-n))

def verovatnoca(x):
    if x[0]%2 or x[1]%2:
        return 0
    elif x[0]==2 or x[1]==2:
        return 1 / max(x[0], x[1])
    elif x[0]==4 or x[1]==4:
        return 1/8
    else:
        return 1 - (1/4 + 1/6 + 1/8 + 1/8 + 1/8)

P_uzorka = []
for i in range(len(uzorci)):
    P_uzorka.append(verovatnoca(uzorci[i]))

print(P_uzorka)

sum(P_uzorka) # == 1 ?

Y_sr = []
for i in range(len(uzorci)):
    Y_sr.append(statistics.mean([Y[uzorci[i][0]-1], Y[uzorci[i][1]-1]]))

print(Y_sr)

E_Y_sr = sum([x*y for x,y in zip(Y_sr, P_uzorka)])
print(E_Y_sr)

meanY = statistics.mean(Y)
print(meanY)
# meanY != E_Y_sr -> ocena nije nepristrasna

MSE_Y_sr = sum([ (x-meanY)**2 * y for x,y in zip(Y_sr, P_uzorka) ])
print(MSE_Y_sr)

"""**5. Iz populacije {1,2,...,100} izvaditi 15 prostih slučajnih uzoraka bez ponavljanja obima 20. Na svakom od njih naći ocenu ukupne sume obeležja i ispitati koji od uzoraka je najreprezentativniji, tj. gde je realizovana vrednost statistike t=NY najbliža stvarnoj vrednosti.**"""

import random
import numpy as np

populacija = list(range(1,101))
Y = populacija

n = 20
N = len(populacija)

uzorci = []
for i in range(15):
    uzorci.append(random.sample(populacija, n))

print(uzorci)

# Za PSU sa ponavljanjem:
# import numpy as np
# np.random.choice(populacija, n, replace=True)

t_ocene = [ N*statistics.mean(x) for x in uzorci ]
print(t_ocene)

t = sum(Y)
print(t)

pom = [abs(x-t) for x in t_ocene] 

t_najbliza = t_ocene[np.where(pom == np.min(pom))[0][0]]
print(t_najbliza)

najreprez = np.where(pom == np.min(pom))[0][0]
najreprez_uzorak = uzorci[najreprez]
print(najreprez_uzorak)

"""**6. Data je populacija {1,2,3,4,5,6,7,8} i razmotren je sledeći plan uzorkovanja: \\
{1,3,5,6} - P(S)=1/8, \\
{2,3,7,8} - P(S)=1/4, \\
{1,4,6,8} - P(S)=1/8, \\
{2,4,6,8} - P(S)=3/8, \\
{4,5,7,8} - P(S)=1/8 \\
Ispitati nepristrasnost ocene t = NY.**
"""

populacija = [1, 2, 3, 4, 5, 6, 7, 8]
Y = populacija

N = len(populacija)

s1 = [1, 3, 5, 6]
s2 = [2, 3, 7, 8]
s3 = [1, 4, 6, 8]
s4 = [2, 4, 6, 8]
s5 = [4, 5, 7, 8]

uzorci = [s1, s2, s3, s4, s5]
P_uzorka = [1/8, 1/4, 1/8, 3/8, 1/8]

sum(P_uzorka)

Y_sr = []
for i in range(len(uzorci)):
    Y_sr.append(statistics.mean([Y[uzorci[i][0]-1], Y[uzorci[i][1]-1], Y[uzorci[i][2]-1], Y[uzorci[i][3]-1]]))

print(Y_sr)

t_ocena = [ N*y for y in Y_sr]
print(t_ocena)

E_t_ocena = sum([x*y for x,y in zip(t_ocena, P_uzorka)])
print(E_t_ocena)

t = sum(Y)
print(t)
# t != E_t_ocena -> ocena nije nepristrasna