# -*- coding: utf-8 -*-
"""cas02.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zNWm-aiSo9ENe14idguAnzVWtzCU0HUD

**1. U restoranu se sluze cetiri vrste kolaca - baklave, tulumbe, ekleri i sampite. Desetoro ljudi je kupilo baklavu, dvadesetoro tulumbu, dvadeset i petoro ekler, a petnaestoro sampitu. Na slucajan nacin se odaberu 2 razlicite vrste kolaca i belezi se broj ljudi koji su kupili tu vrstu. \\
a) Oceniti ukupan broj osoba koje su kupile kolac, a zatim  ispitati nepristrasnost ocene koja se koristi. \\
b) Ispitati da li je uzoracka disperzija nepristrasna ocena disperzije na citavoj populaciji.**
"""

import random
import statistics
from itertools import combinations

populacija = [1, 2, 3, 4] # baklava, tulumbe, ekleri, sampita
Y = [10, 20, 25, 15]

N = len(populacija)
n = 2

uzorak = random.sample(populacija, n)

t_ocena = N*statistics.mean([Y[uzorak[0]-1], Y[uzorak[1]-1]])
print(t_ocena)

"""**(a)**"""

M = combinations(populacija, n)
M = list(M)
print(M)

P_uzorka = [1/6 for _ in range(len(M))]
print(P_uzorka)

Y_sr = []
for i in range(len(M)):
    Y_sr.append(statistics.mean([Y[M[i][0]-1], Y[M[i][1]-1]]))
print(Y_sr)

E_t_ocena = N * sum([ y*p for y,p in zip(Y_sr, P_uzorka) ])
print(E_t_ocena)

t = sum(Y)
print(t)

E_t_ocena == t # True -> ocena je nepristrasna

"""**(b)**"""

sigma_2 = statistics.variance(Y)
print(sigma_2)

S_2 = []
for i in range(len(M)):
    S_2.append(statistics.variance([Y[M[i][0]-1], Y[M[i][1]-1]]))

print(S_2)

E_S_2 = sum([ s*p for s,p in zip(S_2, P_uzorka) ])
print(E_S_2)

round(sigma_2, 5) == round(E_S_2, 5) # True -> ocena je nepristrasna

"""**2. Uzet je prost slucajan uzorak bez ponavljanja od 10 ucenika od 100 ucenika treceg razreda i belezene su njihove ocene iz matematike. Zabelezeni su rezultati: (4,5,5,2,3,1,3,4,4,5). Oceniti prosecnu ocenu iz matematike, a zatim izracunati ocenu disperzije te ocene.**"""

N = 100
n = 10

Y = [4, 5, 5, 2, 3, 1, 3, 4, 4, 5]

Y_sr = statistics.mean(Y)
print(Y_sr)

ocena_D_Y_sr = (statistics.variance(Y) / n) * (1 - n/N) 
print(ocena_D_Y_sr)

"""**3. Uzet je prost slucajan uzorak od 10 razlicitih kuca od  100 kuca koje se nalaze u jednom naselju. Broj stanovnika u kucama iz uzorka je 2,5,1,4,4,3,2,5,2,3. \\
a) Oceniti ukupan broj stanovnika u tom naselju i oceniti disperziju te ocene. \\
b) Oceniti prosecan broj stanovnika po kuci i oceniti disperziju te ocene. \\
c) Naci priblizni 90%-ni interval poverenja za ukupan broj stanovnika.**
"""

N = 100
n = 10

Y = [2, 5, 1, 4, 4, 3, 2, 5, 2, 3]

"""**(a)**"""

t_ocena = N * statistics.mean(Y)
print(t_ocena)

ocena_D_t_ocena = (statistics.variance(Y)/n) * (1-n/N) * N**2
print(ocena_D_t_ocena)

"""**(b)**"""

Y_sr = statistics.mean(Y)
print(Y_sr)

ocena_D_Y_sr = (statistics.variance(Y)/n) * (1-n/N)
print(ocena_D_Y_sr)

"""**(c)**"""

from scipy.stats import t
import math

alpha = 1 - 0.9

# n < 30 -> studentova raspodela
z_student = t.ppf(1-alpha/2, n-1)
print(z_student)

koren = math.sqrt( (statistics.variance(Y)/n) * (1-n/N) * N**2 )
interval = [t_ocena - z_student * koren, t_ocena + z_student * koren]
print(interval)

"""**4. Botanicar zeli da oceni broj stabala breze u nekoj oblasti. Oblast je podeljena na 1000 delova. Poznato je iz prethodnih ispitivanja da je disperzija broja stabala po oblasti priblizno 45. Odrediti velicinu prostog slucajnog uzorka bez ponavljanja, potrebnu da sa verovatnocom 0.95 odstupanje ne bude vece od 500 stabala.**"""

from scipy.stats import norm

N = 1000
sigma_2 = 45
alpha = 1-0.95
delta = 500

z = norm.ppf(1-alpha/2)
print(z)

n = (delta**2 / (z**2 * sigma_2 * N**2) + 1/N)**(-1)
n = math.ceil(n)
print(n)

"""**5. Posmatramo populaciju obima 5, ciji su elementi oznaceni brojevima 1,2,3,4,5, a vrednosti obelezja su redom 3,1,0,1,5. Razmotrimo princip prostog slucajnog uzorkovanja bez ponavljanja za uzorak obima 3. Pokazati da je srednja vrednost obelezja na uzorku nepristrasna ocena srednje
vrednosti obelezja populacije.**
"""

N = 5
n = 3

populacija = list(range(1,6))
Y = [3, 1, 0, 1, 5]

M = combinations(populacija, n)
M = list(M)
print(M)

P_uzorka = [1/len(M) for _ in range(len(M))]
print(P_uzorka)

Y_sr = []
for i in range(len(M)):
    Y_sr.append(statistics.mean([ Y[M[i][0]-1], Y[M[i][1]-1], Y[M[i][2]-1] ]))

print(Y_sr)

E_Y_sr = sum([ y*p for y,p in zip(Y_sr, P_uzorka) ])
print(E_Y_sr)

E_Y_sr == statistics.mean(Y) # True -> ocena je nepristrasna

"""**6. U datoteci deca.txt dati su podaci o broju dece u svakoj od 512 ulica u nekom gradu. Naci 95%-ni interval poverenja za ukupan broj dece u tom gradu koristeci prost slucajan uzorak bez ponavljanja obima 200.**"""

import pandas as pd

N = 512
n = 200

deca = pd.read_csv("deca.txt", sep=" ")
print(deca.head())

uzorak = random.sample(list(deca['ulica']), n)

t_ocena = N * statistics.mean( deca['br_dece'][uzorak] )
print(t_ocena)

alpha = 1 - 0.95

z = norm.ppf(1-alpha/2)

# n > 30 pa mozemo da koristimo normalnu raspodelu
S_2 = statistics.variance(deca['br_dece'][uzorak])
print(S_2)

koren = math.sqrt( (S_2/n) * (1-n/N) * N**2 )
interval = [t_ocena - z * koren, t_ocena + z * koren]
print(interval)

"""**7. Za koji od sledecih planova prostog slucajnog uzorkovanja bez ponavljanja ce biti dobijena najpreciznija ocena srednje vrednosti obelezja na populaciji? Pretpostavimo da obelezje na svakoj od populacija ima disperziju 100. \\
a) uzorak obima 400, dobijen iz populacije obima 4000 \\
b) uzorak obima 30, dobijen iz populacije obima 300 \\
c) uzorak obima 3000, dobijen iz populacije obima 300000000.**
"""

sigma_2 = 100

D_Y_sr_1 = (sigma_2 / 400) * (1 - 400/4000)
D_Y_sr_2 = (sigma_2 / 30) * (1-30/300)
D_Y_sr_3 = (sigma_2 / 3000) * (1-3000/300000000)

D_Y_sr = [D_Y_sr_1, D_Y_sr_2, D_Y_sr_3]
res = D_Y_sr.index(min(D_Y_sr))
print(res) # 2 -> D_Y_sr_3