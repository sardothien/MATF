/* –†–∏–º—ô–∞–Ω–∏ –æ–ø–µ—Ç –Ω–∞–ø–∞–¥–∞—ò—É –ì–∞–ª–µ. –£ –≥–∞–ª—Å–∫–æ–º —Å–µ–ª—É –ø–æ—Å—Ç–æ—ò–∏ N —Å—Ç—É–±–æ–≤–∞ –æ–∫–æ –∫–æ—ò–∏—Ö
 * —Å–µ –º–æ–≥—É –≥—Ä–∞–¥–∏—Ç–∏ –∑–∞—à—Ç–∏—Ç–Ω–µ –∑–∏–¥–∏–Ω–µ –∏ –ú –∫—É—õ–∞. –ó–∞—à—Ç–∏—Ç–Ω–µ –∑–∏–¥–∏–Ω–µ —Å–µ –≥—Ä–∞–¥–µ —Ç–∞–∫–æ
 * —à—Ç–æ —Å–µ –ø–æ–¥–∏–∂—É –∏–∑–º–µ—í—É —Å—Ç—É–±–æ–≤–∞. –î–∞–∫–ª–µ, –∏–∑–º–µ—í—É —Å–≤–∞–∫–∞ 2 —Å—Ç—É–±–∞ –º–æ–∂–µ–º–æ –∏–∑–≥—Ä–∞–¥–∏—Ç–∏
 * –¥–µ–æ –∑–∏–¥–∞. –ü–æ–º–æ–∑–∏—Ç–µ –ì–∞–ª–∏–º–∞ –¥–∞ —É—Ç–≤—Ä–¥–µ –¥–∞ –ª–∏ –º–æ–≥—É –¥–∞ –∏–∑–≥—Ä–∞–¥–µ –∑–∞—à—Ç–∏—Ç–Ω–µ –∑–∏–¥–∏–Ω–µ
 * –æ–∫–æ —Å—Ç—É–±–æ–≤–∞ –∏ –¥–∞ –∑–∞—à—Ç–∏—Ç–µ —Å–≤–µ –∫—É—õ–µ —É —Å–µ–ª—É. –£ –ø—Ä–≤–æ—ò –ª–∏–Ω–∏—ò–∏ —Å—Ç–∞–Ω–¥–∞—Ä–¥–Ω–æ–≥ —É–ª–∞–∑–∞
 * —Å–µ —É–Ω–æ—Å–µ –±—Ä–æ—ò–µ–≤–∏ N –∏ –ú. –£ –Ω–∞—Ä–µ–¥–Ω–∏—Ö N –ª–∏–Ω–∏—ò–∞ —Å–µ —É–Ω–æ—Å–µ –ø–æ 2 –±—Ä–æ—ò–∞ –∫–æ—ò–∞
 * –ø—Ä–µ–¥—Å—Ç–∞–≤—ô–∞—ò—É –ø–æ–∑–∏—Ü–∏—ò–µ —Å—Ç—É–±–æ–≤–∞. –ù–∞–∫–æ–Ω —Ç–æ–≥–∞ —Å–µ —É –Ω–∞—Ä–µ–¥–Ω–∏—Ö –ú –ª–∏–Ω–∏—ò–∞ —É–Ω–æ—Å–µ
 * –ø–æ–∑–∏—Ü–∏—ò–µ –∫—É—õ–∞ —É —Å–µ–ª—É. –£ —ò–µ–¥–∏–Ω–æ—ò –ª–∏–Ω–∏—ò–∏ —Å—Ç–∞–Ω–¥–∞—Ä–¥–Ω–æ–≥ –∏–∑–ª–∞–∑–∞ –∏—Å–ø–∏—Å–∞—Ç–∏ NE –∞–∫–æ
 * —ò–µ –Ω–µ–º–æ–≥—É—õ–µ –æ–≥—Ä–∞–¥–∏—Ç–∏ —Å–≤–µ –∫—É—õ–µ –∑–∞—à—Ç–∏—Ç–Ω–æ–º –æ–≥—Ä–∞–¥–æ–º –∫–æ—ò–∞ —Å–µ —Ñ–æ—Ä–º–∏—Ä–∞ –æ–∫–æ —Å—Ç—É–±–æ–≤–∞,
 * –∞ D–ê –∏–Ω–∞—á–µ. –°–ª–æ–∂–µ–Ω–æ—Å—Ç –∞–ª–≥–æ—Ä–∏—Ç–º–∞ —Ç—Ä–µ–±–∞ –¥–∞ –±—É–¥–µ –û(ùëÅlogùëÅ). –í—Ä–µ–¥–Ω–æ—Å—Ç–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞
 * –ø–æ –∞–ø—Å–æ–ª—É—Ç–Ω–æ—ò –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ –Ω–µ—õ–µ –ø—Ä–µ–ª–∞–∑–∏—Ç–∏ 500. –í—Ä–µ–¥–Ω–æ—Å—Ç–∏ –ø—Ä–∏—Ä–æ–¥–Ω–∏—Ö –±—Ä–æ—ò–µ–≤–∞
 * N –∏ –ú –Ω–µ—õ–µ –ø—Ä–µ–ª–∞–∑–∏—Ç–∏ 1000. –ù–∞–ø–æ–º–µ–Ω–∞: –ù–µ –º–æ—Ä–∞—ò—É —Å–≤–∏ —Å—Ç—É–±–æ–≤–∏ –±–∏—Ç–∏ –∏—Å–∫–æ—Ä–∏—à—õ–µ–Ω–∏. */

#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

struct Tacka {
    int x, y;
    bool zid;
};

Tacka P0;

int orijentacija(Tacka& A, Tacka& B, Tacka& C){
    int d = (B.y-A.y)*(C.x-A.x) - (C.y-A.y)*(B.x-A.x);
    if(d == 0)
        return 0;
    else if(d > 0)
        return 1;
    else
        return -1;
}

int rastojanje(Tacka& A, Tacka& B){
    return (A.x-B.x)*(A.x-B.x) + (A.y-B.y)*(A.y-B.y);
}
bool poredi(Tacka& t1, Tacka& t2){
    int o = orijentacija(P0, t1, t2);
    if(o == 0)
        return rastojanje(P0, t1) < rastojanje(P0, t2);
    else if(o == 1)
        return false;
    else
        return true;
}

void swap(Tacka& A, Tacka& B){
    Tacka pom = A;
    A = B;
    B = pom;
}

int nadji_max(vector<Tacka>& tacke){
    int max_x = tacke[0].x;
    int min_y = tacke[0].y;
    int ind = 0;

    int n = tacke.size();

    for(int i = 1; i < n; i++){
        if(tacke[i].x > max_x){
            max_x = tacke[i].x;
            min_y = tacke[i].y;
            ind = i;
        }
        else if(tacke[i].x == max_x && tacke[i].y < min_y){
            min_y = tacke[i].y;
            ind = i;
        }
    }

    return ind;
}

void konveksniOmotac(vector<Tacka>& tacke){

    int max = nadji_max(tacke);

    swap(tacke[0], tacke[max]);

    P0 = tacke[0];

    sort(tacke.begin()+1, tacke.end(), poredi);

    vector<Tacka> rezultat;

    rezultat.push_back(tacke[0]);
    rezultat.push_back(tacke[1]);
    rezultat.push_back(tacke[2]);

    int n = tacke.size();
    int m = 2;

    for(int k = 3; k < n; k++){
        while(orijentacija(rezultat[m-1], rezultat[m], tacke[k]) == 1){
            rezultat.pop_back();
            m--;
        }

        m++;
        rezultat.push_back(tacke[k]);
    }

    for(Tacka& t : rezultat)
        if(t.zid == false){
            cout << "NE" << endl;
            return;
        }

    cout << "DA" << endl;
}

int main(){

    int n, m;
    cin >> n >> m;

    vector<Tacka> tacke(n+m);

    for(int i = 0; i < n; i++){
        cin >> tacke[i].x >> tacke[i].y;
        tacke[i].zid = true;
    }

    for(int i = n; i < m+n; i++){
        cin >> tacke[i].x >> tacke[i].y;
        tacke[i].zid = false;
    }

    konveksniOmotac(tacke);

    return 0;
}
